# Comparing `tmp/reyworm-0.3-py3-none-any.whl.zip` & `tmp/reyworm-0.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,26 @@
-Zip file size: 31617 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat      237 b- defN 23-Apr-18 09:19 reyapi/__init__.py
--rw-rw-rw-  2.0 fat      715 b- defN 23-Apr-18 09:19 reytool/__init__.py
--rw-rw-rw-  2.0 fat     9517 b- defN 23-Apr-04 12:10 reytool/rbasic.py
--rw-rw-rw-  2.0 fat     8690 b- defN 23-Apr-18 09:18 reytool/rcommon.py
--rw-rw-rw-  2.0 fat     3271 b- defN 23-Mar-21 09:55 reytool/rcompress.py
--rw-rw-rw-  2.0 fat    11618 b- defN 23-Apr-14 08:35 reytool/rdata.py
--rw-rw-rw-  2.0 fat    22241 b- defN 23-Apr-10 05:02 reytool/rdatabase.py
--rw-rw-rw-  2.0 fat    16545 b- defN 23-Apr-14 09:19 reytool/rdatetime.py
--rw-rw-rw-  2.0 fat     6097 b- defN 23-Mar-30 03:12 reytool/remail.py
--rw-rw-rw-  2.0 fat     4045 b- defN 23-Apr-04 15:53 reytool/rmonkey.py
--rw-rw-rw-  2.0 fat     3054 b- defN 23-Mar-22 06:09 reytool/rmultitask.py
--rw-rw-rw-  2.0 fat      786 b- defN 23-Mar-21 09:55 reytool/roption.py
--rw-rw-rw-  2.0 fat     2607 b- defN 23-Mar-22 06:00 reytool/rregular.py
--rw-rw-rw-  2.0 fat     5173 b- defN 23-Mar-22 06:11 reytool/rrequest.py
--rw-rw-rw-  2.0 fat     8813 b- defN 23-Apr-04 15:53 reytool/rtext.py
--rw-rw-rw-  2.0 fat     8402 b- defN 23-Apr-04 12:31 reytool/rwrap.py
--rw-rw-rw-  2.0 fat      275 b- defN 23-Apr-18 09:19 reyworm/__init__.py
--rw-rw-rw-  2.0 fat     1207 b- defN 23-Apr-18 09:17 reyworm/rtranslate.py
--rw-rw-rw-  2.0 fat      202 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1645 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/RECORD
-22 files, 115240 bytes uncompressed, 29019 bytes compressed:  74.8%
+Zip file size: 33269 bytes, number of entries: 24
+-rw-rw-rw-  2.0 fat      240 b- defN 23-Apr-22 14:42 reytool/__init__.py
+-rw-rw-rw-  2.0 fat     9539 b- defN 23-Apr-22 14:38 reytool/rbase.py
+-rw-rw-rw-  2.0 fat      708 b- defN 23-Apr-22 14:42 reytool/rcommon.py
+-rw-rw-rw-  2.0 fat     3502 b- defN 23-Apr-22 14:38 reytool/rcompress.py
+-rw-rw-rw-  2.0 fat    11743 b- defN 23-Apr-22 14:38 reytool/rdata.py
+-rw-rw-rw-  2.0 fat    22288 b- defN 23-Apr-22 14:40 reytool/rdatabase.py
+-rw-rw-rw-  2.0 fat    16670 b- defN 23-Apr-22 14:39 reytool/rdatetime.py
+-rw-rw-rw-  2.0 fat     6108 b- defN 23-Apr-22 14:38 reytool/remail.py
+-rw-rw-rw-  2.0 fat     1760 b- defN 23-Apr-22 14:38 reytool/rimage.py
+-rw-rw-rw-  2.0 fat     4084 b- defN 23-Apr-22 14:38 reytool/rmonkey.py
+-rw-rw-rw-  2.0 fat     3054 b- defN 23-Apr-22 14:38 reytool/rmultitask.py
+-rw-rw-rw-  2.0 fat      786 b- defN 23-Apr-22 14:38 reytool/roption.py
+-rw-rw-rw-  2.0 fat     9043 b- defN 23-Apr-22 14:38 reytool/rother.py
+-rw-rw-rw-  2.0 fat     2766 b- defN 23-Apr-22 14:38 reytool/rregular.py
+-rw-rw-rw-  2.0 fat     6195 b- defN 23-Apr-22 14:38 reytool/rrequest.py
+-rw-rw-rw-  2.0 fat     8853 b- defN 23-Apr-22 14:38 reytool/rtext.py
+-rw-rw-rw-  2.0 fat     8411 b- defN 23-Apr-22 14:39 reytool/rwrap.py
+-rw-rw-rw-  2.0 fat      238 b- defN 23-Apr-22 14:46 reyworm/__init__.py
+-rw-rw-rw-  2.0 fat      207 b- defN 23-Apr-22 14:46 reyworm/rcommon.py
+-rw-rw-rw-  2.0 fat     1320 b- defN 23-Apr-22 14:46 reyworm/rtranslate.py
+-rw-rw-rw-  2.0 fat      202 b- defN 23-Apr-22 14:47 reyworm-0.4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-22 14:47 reyworm-0.4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 23-Apr-22 14:47 reyworm-0.4.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1791 b- defN 23-Apr-22 14:47 reyworm-0.4.dist-info/RECORD
+24 files, 119608 bytes uncompressed, 30453 bytes compressed:  74.5%
```

## zipnote {}

```diff
@@ -1,14 +1,11 @@
-Filename: reyapi/__init__.py
-Comment: 
-
 Filename: reytool/__init__.py
 Comment: 
 
-Filename: reytool/rbasic.py
+Filename: reytool/rbase.py
 Comment: 
 
 Filename: reytool/rcommon.py
 Comment: 
 
 Filename: reytool/rcompress.py
 Comment: 
@@ -21,23 +18,29 @@
 
 Filename: reytool/rdatetime.py
 Comment: 
 
 Filename: reytool/remail.py
 Comment: 
 
+Filename: reytool/rimage.py
+Comment: 
+
 Filename: reytool/rmonkey.py
 Comment: 
 
 Filename: reytool/rmultitask.py
 Comment: 
 
 Filename: reytool/roption.py
 Comment: 
 
+Filename: reytool/rother.py
+Comment: 
+
 Filename: reytool/rregular.py
 Comment: 
 
 Filename: reytool/rrequest.py
 Comment: 
 
 Filename: reytool/rtext.py
@@ -45,23 +48,26 @@
 
 Filename: reytool/rwrap.py
 Comment: 
 
 Filename: reyworm/__init__.py
 Comment: 
 
+Filename: reyworm/rcommon.py
+Comment: 
+
 Filename: reyworm/rtranslate.py
 Comment: 
 
-Filename: reyworm-0.3.dist-info/METADATA
+Filename: reyworm-0.4.dist-info/METADATA
 Comment: 
 
-Filename: reyworm-0.3.dist-info/WHEEL
+Filename: reyworm-0.4.dist-info/WHEEL
 Comment: 
 
-Filename: reyworm-0.3.dist-info/top_level.txt
+Filename: reyworm-0.4.dist-info/top_level.txt
 Comment: 
 
-Filename: reyworm-0.3.dist-info/RECORD
+Filename: reyworm-0.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## reytool/__init__.py

```diff
@@ -7,23 +7,9 @@
 @Contact : reyxbo@163.com
 @Explain : Rey's personal tool set.
 """
 
 
 from typing import Final
 
-from .rbasic import warn
-from .rcompress import rzip
-from .rcommon import exc, digits, randn, sleep, get_paths, n_to_ch
-from .rdata import count, flatten, split, distinct
-from .rdatabase import REngine
-from .rdatetime import RDateTimeMark, now, time_to_str, str_to_time
-from .remail import REmail
-from .rmultitask import threads
-from . import roption
-from .rregular import res
-from .rrequest import request
-from .rtext import rprint
-from .rwrap import runtime
 
-
-__version__: Final[str] = "0.105"
+__version__: Final[str] = "0.111"
```

## reytool/rcommon.py

```diff
@@ -5,307 +5,21 @@
 @Time    : 2022-12-08 13:11:09
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's common methods.
 """
 
 
-from typing import List, Tuple, Literal, Optional, Union
-import os
-import re
-import time
-import random
-from traceback import format_exc
-
+from .rbase import warn
+from .rcompress import rzip
+from .rother import exc, digits, randn, sleep, get_paths, n2ch
+from .rdata import count, flatten, split, unique
+from .rdatabase import REngine
+from .rdatetime import RDateTimeMark, now, time2str, str2time
+from .remail import REmail
+from .rimage import encode_qrcode, decode_qrcode
+from .rmultitask import threads
 from . import roption
+from .rregular import res_search, res_sub
+from .rrequest import request, download
 from .rtext import rprint
-
-
-def exc(title: str = "Error", report: bool = True) -> str:
-    """
-    Print and return error messages, must used in 'except' syntax.
-
-    Parameters
-    ----------
-    title : Print title.
-    report : Whether print error messages.
-
-    Returns
-    -------
-    Error messages.
-    """
-
-    # Get error information.
-    error = format_exc()
-    error = error.strip()
-
-    # Report.
-    if report:
-        rprint(error, title=title, frame=roption.print_default_frame_half)
-
-    return error
-
-def digits(number: Union[int, float]) -> Tuple[int, int]:
-    """
-    Judge the number of integer digits and deciaml digits.
-
-    Parameters
-    ----------
-    number : Number to judge.
-
-    Returns
-    -------
-    Integer digits and deciaml digits.
-    """
-
-    # Handle parameters.
-    number_str = str(number)
-
-    # Get digits.
-    if "." in number_str:
-        integer_str, decimal_str = number_str.split(".")
-        integer_digits = len(integer_str)
-        deciaml_digits = len(decimal_str)
-    else:
-        integer_digits = len(number_str)
-        deciaml_digits = 0
-
-    return integer_digits, deciaml_digits
-
-def randn(*thresholds: Union[int, float], precision: Optional[int] = None) -> Union[int, float]:
-    """
-    Get random number.
-
-    Parameters
-    ----------
-    thresholds : Low and high thresholds of random range, range contains thresholds.
-        - When length is 0, then low and high thresholds is 0 and 10.
-        - When length is 1, then low and high thresholds is 0 and thresholds[0].
-        - When length is 2, then low and high thresholds is thresholds[0] and thresholds[1].
-
-    precision : Precision of random range, that is maximum decimal digits of return value.
-        - None : Set to Maximum decimal digits of element of parameter 'thresholds'.
-        - int : Set to this value.
-
-    Returns
-    -------
-    Random number.
-        - When parameters 'precision' is 0, then return int.
-        - When parameters 'precision' is greater than 0, then return float.
-    """
-
-    # Handle parameters.
-    thresholds_len = len(thresholds)
-    if thresholds_len == 0:
-        threshold_low = 0
-        threshold_high = 10
-    elif thresholds_len == 1:
-        threshold_low = 0
-        threshold_high = thresholds[0]
-    elif thresholds_len == 2:
-        threshold_low = thresholds[0]
-        threshold_high = thresholds[1]
-    else:
-        raise ValueError("number of parameter 'thresholds' must is 0 or 1 or 2")
-    if precision == None:
-        threshold_low_desimal_digits = digits(threshold_low)[1]
-        threshold_high_desimal_digits = digits(threshold_high)[1]
-        desimal_digits_max = max(threshold_low_desimal_digits, threshold_high_desimal_digits)
-        precision = desimal_digits_max
-
-    # Get random number.
-    magnifier = 10 ** precision
-    threshold_low *= magnifier
-    threshold_high *= magnifier
-    number = random.randint(threshold_low, threshold_high)
-    number = number / magnifier
-    if precision == 0:
-        number = int(number)
-
-    return number
-
-def sleep(*thresholds: Union[int, float], precision: Optional[int] = None) -> Union[int, float]:
-    """
-    Sleep random seconds.
-
-    Parameters
-    ----------
-    thresholds : Low and high thresholds of random range, range contains thresholds.
-        - When length is 0, then low and high thresholds is 0 and 10.
-        - When length is 1, then sleep this value.
-        - When length is 2, then low and high thresholds is thresholds[0] and thresholds[1].
-    
-    precision : Precision of random range, that is maximum decimal digits of sleep seconds.
-        - None : Set to Maximum decimal digits of element of parameter 'thresholds'.
-        - int : Set to this value.
-    
-    Returns
-    -------
-    Random seconds.
-        - When parameters 'precision' is 0, then return int.
-        - When parameters 'precision' is greater than 0, then return float.
-    """
-
-    # Handle parameters.
-    thresholds_len = len(thresholds)
-    if thresholds_len == 0:
-        second = randn(0, 10, precision=precision)
-    elif thresholds_len == 1:
-        second = thresholds[0]
-    elif thresholds_len == 2:
-        second = randn(thresholds[0], thresholds[1], precision=precision)
-    else:
-        raise ValueError("number of parameter 'thresholds' must is 0 or 1 or 2")
-
-    # Sleep.
-    time.sleep(second)
-
-    return second
-
-def get_paths(path: Optional[str] = None, target: Literal["all", "file", "folder"] = "all", recursion: bool = True) -> List:
-    """
-    Get the path of files and folders in the path.
-
-    Parameters
-    ----------
-    path : When None, then work path.
-    target : Target data.
-        - "all" : Return file and folder path.
-        - "file : Return file path.
-        - "folder" : Return folder path.
-
-    recursion : Is recursion directory.
-
-    Returns
-    -------
-    String is path.
-    """
-
-    # Handle parameters.
-    if path == None:
-        path = ""
-    path = os.path.abspath(path)
-
-    # Get paths.
-    paths = []
-
-    ## Recursive.
-    if recursion:
-        obj_walk = os.walk(path)
-        if target == "all":
-            targets_path = [
-                os.path.join(path, file_name)
-                for path, folders_name, files_name in obj_walk
-                for file_name in files_name + folders_name
-            ]
-            paths.extend(targets_path)
-        elif target == "file":
-            targets_path = [
-                os.path.join(path, file_name)
-                for path, folders_name, files_name in obj_walk
-                for file_name in files_name
-            ]
-            paths.extend(targets_path)
-        elif target in ["all", "folder"]:
-            targets_path = [
-                os.path.join(path, folder_name)
-                for path, folders_name, files_name in obj_walk
-                for folder_name in folders_name
-            ]
-            paths.extend(targets_path)
-
-    ## Non recursive.
-    else:
-        names = os.listdir(path)
-        if target == "all":
-            for name in names:
-                target_path = os.path.join(path, name)
-                paths.append(target_path)
-        elif target == "file":
-            for name in names:
-                target_path = os.path.join(path, name)
-                is_file = os.path.isfile(target_path)
-                if is_file:
-                    paths.append(target_path)
-        elif target == "folder":
-            for name in names:
-                target_path = os.path.join(path, name)
-                is_dir = os.path.isdir(target_path)
-                if is_dir:
-                    paths.append(target_path)
-
-    return paths
-
-map_digit = {
-    "0": "零",
-    "1": "一",
-    "2": "二",
-    "3": "三",
-    "4": "四",
-    "5": "五",
-    "6": "六",
-    "7": "七",
-    "8": "八",
-    "9": "九",
-}
-
-map_digits = {
-    0: "",
-    1: "十",
-    2: "百",
-    3: "千",
-    4: "万",
-    5: "十",
-    6: "百",
-    7: "千",
-    8: "亿",
-    9: "十",
-    10: "百",
-    11: "千",
-    12: "万",
-    13: "十",
-    14: "百",
-    15: "千",
-    16: "兆"
-}
-
-def n_to_ch(number: int) -> str:
-    """
-    Convert number to chinese number.
-
-    Parameters
-    ----------
-    number : Number to convert.
-
-    Returns
-    -------
-    Chinese number.
-    """
-
-    # Processing parameters.
-    number = str(number)
-
-    # Replace digit.
-    for digit, digit_ch in map_digit.items():
-        number = number.replace(digit, digit_ch)
-
-    # Add digits.
-    number_list = []
-    for index, digit_ch in enumerate(number[::-1]):
-        digits_ch = map_digits[index]
-        number_list.insert(0, digits_ch)
-        number_list.insert(0, digit_ch)
-    number = "".join(number_list)
-
-    # Delete redundant content.
-    pattern = "(?<=零)[^万亿兆]"
-    number = re.sub(pattern, "", number)
-    pattern = "零+"
-    number = re.sub(pattern, "零", number)
-    pattern = "零(?=[万亿兆])"
-    number = re.sub(pattern, "", number)
-    if number[0:2] == "一十":
-        number = number[1:]
-    if number[-1:] == "零":
-        number = number[:-1]
-
-    return number
+from .rwrap import runtime
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## reytool/rcompress.py

```diff
@@ -7,15 +7,22 @@
 @Contact : reyxbo@163.com
 @Explain : Rey's zip methods.
 """
 
 
 from typing import List, Optional
 from zipfile import ZipFile, is_zipfile, ZIP_DEFLATED
-import os
+from os import getcwd as os_getcwd, walk as os_walk
+from os.path import (
+    basename as os_path_basename,
+    splitext as os_path_splitext,
+    join as os_path_join,
+    isdir as os_path_isdir,
+    dirname as os_path_dirname,
+)
 
 
 def compress(obj_path: str, build_dir: Optional[str] = None, overwrite: bool = True) -> None:
     """
     Compress file or folder.
 
     Parameters
@@ -26,46 +33,47 @@
         - str : Use this value.
 
     overwrite : Whether to overwrite.
     """
 
     # Processing parameters.
     if build_dir == None:
-        build_dir = os.getcwd()
+        build_dir = os_getcwd()
     if overwrite:
         mode = "w"
     else:
         mode = "x"
 
     # Generate build path.
-    basename = os.path.basename(obj_path)
-    build_name = os.path.splitext(basename)[0]
+    basename = os_path_basename(obj_path)
+    build_name = os_path_splitext(basename)[0]
     build_name += ".zip"
-    build_path = os.path.join(build_dir, build_name)
+    build_path = os_path_join(build_dir, build_name)
 
     # Compress.
     with ZipFile(build_path, mode, ZIP_DEFLATED) as zip_file:
         zip_file.write(obj_path)
-        is_dir = os.path.isdir(obj_path)
+        is_dir = os_path_isdir(obj_path)
 
         ## Recursive compress.
         if is_dir:
-            dirname = os.path.dirname(obj_path)
+            dirname = os_path_dirname(obj_path)
             dirname_len = len(dirname)
-            dirs = os.walk(obj_path)
+            dirs = os_walk(obj_path)
             for folder_name, sub_folders_name, files_name in dirs:
                 for sub_folder_name in sub_folders_name:
-                    sub_folder_path = os.path.join(folder_name, sub_folder_name)
+                    sub_folder_path = os_path_join(folder_name, sub_folder_name)
                     zip_path = sub_folder_path[dirname_len:]
                     zip_file.write(sub_folder_path, zip_path)
                 for file_name in files_name:
-                    file_path = os.path.join(folder_name, file_name)
+                    file_path = os_path_join(folder_name, file_name)
                     zip_path = file_path[dirname_len:]
                     zip_file.write(file_path, zip_path)
 
+
 def decompress(obj_path: str, build_dir: Optional[str] = None, password: Optional[str] = None) -> None:
     """
     Decompress compressed object.
 
     Parameters
     ----------
     obj_path : Compressed object path.
@@ -81,20 +89,21 @@
     # Check object whether can be decompress.
     is_support = is_zipfile(obj_path)
     if not is_support:
         raise AssertionError("file format that cannot be decompressed")
 
     # Processing parameters.
     if build_dir == None:
-        build_dir = os.getcwd()
+        build_dir = os_getcwd()
 
     # Decompress.
     with ZipFile(obj_path) as zip_file:
         zip_file.extractall(build_dir, pwd=password)
 
+
 def rzip(obj_path: str, build_dir: Optional[str] = None) -> None:
     """
     Automatic judge and compress or decompress object.
 
     Parameters
     ----------
     obj_path : File or folder or compressed object path.
```

## reytool/rdata.py

```diff
@@ -5,25 +5,26 @@
 @Time    : 2022-12-05 14:10:42
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's data methods.
 """
 
 
-from typing import Any, List, Tuple, Dict, Iterable, Literal, Optional, Union, Type, NoReturn, overload
+from typing import Any, List, Dict, Iterable, Literal, Optional, Union, Type, NoReturn, overload
 from pandas import DataFrame, ExcelWriter
+from os.path import abspath as os_path_abspath
 
 # Version compatible of package sqlalchemy.
 try:
     from sqlalchemy import CursorResult
 except ImportError:
     from sqlalchemy.engine.cursor import LegacyCursorResult as CursorResult
 
-from .rbasic import is_iterable, check_least_one, check_most_one, to_type
-from .rdatetime import time_to_str
+from .rbase import is_iterable, check_least_one, check_most_one, to_type
+from .rdatetime import time2str
 
 
 def to_table(
     data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]],
     fields: Optional[Iterable] = None
 ) -> List[Dict]:
     """
@@ -64,14 +65,15 @@
     else:
         data_df = DataFrame(data, columns=fields)
         data_df = data_df.where(data.notnull(), None)
         data_table = data_df.to_dict("records")
 
     return data_table
 
+
 def to_df(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> DataFrame:
     """
     Fetch data to table of DataFrame object.
 
     Parameters
     ----------
     data : Data.
@@ -101,14 +103,15 @@
 
     ## From other object.
     else:
         data_df = DataFrame(data, columns=fields)
 
     return data_df
 
+
 def to_json(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> str:
     """
     Fetch data to JSON string.
 
     Parameters
     ----------
     data : Data.
@@ -125,14 +128,15 @@
     data_df = to_df(data, fields)
 
     # Convert.
     data_json = data_df.to_json(orient="records", force_ascii=False)
 
     return data_json
 
+
 def to_sql(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> str:
     """
     Fetch data to SQL string.
 
     Parameters
     ----------
     data : Data.
@@ -152,15 +156,15 @@
     else:
         data = to_table(data, fields)
         fields = data[0].keys()
 
     # Generate SQL.
     sql_rows_values = [
         [
-            repr(time_to_str(val, "%Y-%m-%d %H:%M:%S"))
+            repr(time2str(val, "%Y-%m-%d %H:%M:%S"))
             if val != None
             else "NULL"
             for val in row
         ]
         for row in data
     ]
     sql_rows = [
@@ -174,14 +178,15 @@
         ]
     )
     sql_rows[0] = sql_row_first
     data_sql = " UNION ALL ".join(sql_rows)
 
     return data_sql
 
+
 def to_html(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> str:
     """
     Fetch data to HTML string.
 
     Parameters
     ----------
     data : Data.
@@ -198,45 +203,52 @@
     data_df = to_df(data, fields)
 
     # Convert.
     data_html = data_df.to_html(col_space=50, index=False, justify="center")
 
     return data_html
 
+
 def to_csv(
     data: Union[CursorResult, DataFrame, Iterable[Dict], Iterable],
-    path: str = "table.csv",
+    path: str = "data.csv",
     fields: Optional[Iterable] = None
-) -> DataFrame:
+) -> str:
     """
     Fetch data to save csv format file.
 
     Parameters
     ----------
     data : Data.
     path : File save path.
     fields : Table fields.
         - None : Infer.
         - Iterable : Use values in Iterable.
+
+    Returns
+    -------
+    File absolute path.
     """
 
     # Handle parameters.
     data_df = to_df(data, fields)
+    path = os_path_abspath(path)
 
     # Save file.
     data_df.to_csv(path, mode="a")
 
-    return data_df
+    return path
+
 
 def to_excel(
     data: Union[CursorResult, DataFrame, Iterable[Dict], Iterable],
-    path: str = "table.xlsx",
+    path: str = "data.xlsx",
     group_field: Optional[str] = None,
     sheets_set: Dict[Union[str, int], Dict[Literal["name", "index", "filter"], Union[str, int, List[str]]]] = {}
-) -> List[Tuple[str, DataFrame]]:
+) -> str:
     """
     Fetch data to save excel format file and return sheet name and sheet data.
 
     Parameters
     ----------
     data : Data.
     path : File save path.
@@ -245,20 +257,21 @@
         key is old name or index, value is set parameters.
         - Parameter 'name' : Set sheet new name.
         - Parameter 'index' : Sort sheet.
         - Parameter 'filter' : Filter sheet fields.
 
     Returns
     -------
-    Sheet name and sheet data.
+    File absolute path.
     """
 
     # Handle parameters.
     if type(data) != DataFrame:
         data = to_df(data)
+    path = os_path_abspath(path)
 
     # Generate sheets.
     if group_field == None:
         data_group = (("Sheet1", data),)
     else:
         data_group = data.groupby(group_field)
     sheets_table_before = []
@@ -287,15 +300,17 @@
     sheets_table = [sheet_table for sheet_index, sheet_table in sheets_table_before] + sheets_table_after
 
     # Save file.
     excel = ExcelWriter(path)
     for sheet_name, sheet_df in sheets_table:
         sheet_df.to_excel(excel, sheet_name, index=False)
     excel.close()
-    return sheets_table
+
+    return path
+
 
 def count(
     data: Any,
     count_value: Dict = {"size": 0, "total": 0, "types": {}},
     surface: bool = True
 ) -> Dict[Literal["size", "total", "types"], Union[int, Dict[Type, int]]]:
     """
@@ -332,14 +347,15 @@
         ## Sort by count.
         sorted_func = lambda key: count_value["types"][key]
         sorted_key = sorted(count_value["types"], key=sorted_func, reverse=True)
         count_value["types"] = {key: count_value["types"][key] for key in sorted_key}
 
         return count_value
 
+
 def flatten(data: Any, flattern_data: List = []) -> List:
     """
     Flatten data.
 
     Parameters
     ----------
     data : Data.
@@ -364,14 +380,15 @@
 
     ## Other.
     else:
         flattern_data.append(data)
 
     return flattern_data
 
+
 @overload
 def split(data: Iterable, share: Optional[int] = None, bin_size: Optional[int] = None) -> List[List]: ...
 
 @overload
 def split(share: None, bin_size: None) -> NoReturn: ...
 
 @overload
@@ -420,15 +437,16 @@
             _data.append(_data)
             _data_len += bin_size
             if _data_len > data_len:
                 break
 
     return _data
 
-def distinct(data: Iterable) -> List:
+
+def unique(data: Iterable) -> List:
     """
     De duplication of data.
 
     Parameters
     ----------
     data : Data.
 
@@ -437,10 +455,10 @@
     List after de duplication.
     """
 
     # Handle parameters.
     data = to_type(data, tuple)
 
     # Delete duplicate.
-    data_de_dup = list(set(data))
-    data_de_dup.sort(key=data.index)
-    return data_de_dup
+    data_unique = list(set(data))
+    data_unique.sort(key=data.index)
+    return data_unique
```

## reytool/rdatabase.py

```diff
@@ -12,19 +12,19 @@
 from typing import Any, List, Dict, Iterable, Optional, Literal, Union, ClassVar, NoReturn, overload
 from re import findall
 from sqlalchemy import create_engine as sqlalchemy_create_engine, text
 from sqlalchemy.engine.base import Engine, Connection
 from sqlalchemy.engine.url import URL
 from sqlalchemy.sql.elements import TextClause
 
-from .rbasic import get_first_notnull
+from .rbase import get_first_notnull
 from .rdata import to_table
 from .rmonkey import add_result_more_fetch, support_row_index_by_field
 from . import roption
-from .rregular import res
+from .rregular import re_search
 from .rtext import rprint
 from .rwrap import runtime
 
 # Version compatible of package sqlalchemy.
 try:
     from sqlalchemy import CursorResult
 except ImportError:
@@ -33,22 +33,25 @@
 
 # Add more methods to CursorResult object of sqlalchemy package.
 add_result_more_fetch()
 
 # Support Row object index by field name.
 support_row_index_by_field()
 
+
 class REngine(object):
     """
     Rey's database Engine type, based on the package sqlalchemy.
     """
 
+
     # Values to be converted to "NULL".
     null_values: ClassVar[List] = ["", " ", b"", [], (), {}, set()]
 
+
     @overload
     def __init__(
         self,
         username: Optional[str] = None,
         password: Optional[str] = None,
         host: Optional[str] = None,
         port: Optional[str] = None,
@@ -126,24 +129,25 @@
             self.engine = engine
 
         # From parameters create.
         else:
 
             ## Extract parameters from URL of str object.
             if type(url) == str:
-                pattern = "^([\w\+]+)://(\w+):(\w+)@(\d+\.\d+\.\d+\.\d+):(\d+)[/]?(\w+)?[\?]?([\w&=]+)?$"
-                url_params = res(url, pattern)
+                pattern = "^([\w\+]+)://(\w+):(\w+)@(\d+\.\d+\.\d+\.\d+):(\d+)[/]?([\w/]+)?[\?]?([\w&=]+)?$"
+                url_params = re_search(pattern, url)
                 if url_params == None:
                     raise ValueError("the value of parameter 'url' is incorrect")
+                url_drivername, url_username, url_password, url_host, url_port, url_database, url_query_str = url_params
+                if url_query_str != None:
+                    pattern = "(\w+)=(\w+)"
+                    url_query_findall = findall(pattern, url_query_str)
+                    url_query = {key: val for key, val in url_query_findall}
                 else:
-                    url_drivername, url_username, url_password, url_host, url_port, url_database, url_query_str = url_params
-                    if url_query_str != None:
-                        pattern = "(\w+)=(\w+)"
-                        url_query_findall = findall(pattern, url_query_str)
-                        url_query = {key: val for key, val in url_query_findall}
+                    url_query = {}
 
             ## Extract parameters from URL of URL object.
             elif type(url) == URL:
                 url_drivername = url.drivername
                 url_username = url.username
                 url_password = url.password
                 url_host = url.host
@@ -159,20 +163,21 @@
             ## Set parameters by priority.
             self.drivername = get_first_notnull(drivername, url_drivername)
             self.username = get_first_notnull(username, url_username, default="error")
             self.password = get_first_notnull(password, url_password, default="error")
             self.host = get_first_notnull(host, url_host, default="error")
             self.port = get_first_notnull(port, url_port, default="error")
             self.database = get_first_notnull(database, url_database)
-            self.query = get_first_notnull(query, url_query, default={"charset": "utf8"}, null_values=[{}])
+            self.query = get_first_notnull(query, url_query, default={}, null_values=[{}])
             self.recycle = recycle
 
             ## Create Engine object.
             self.engine = self.create_engine()
 
+
     def url(self) -> str:
         """
         Generate server URL.
 
         Returns
         -------
         Server URL.
@@ -193,14 +198,15 @@
                     for key, val in self.query.items()
                 ]
             )
             _url = f"{_url}?{query}"
 
         return _url
 
+
     def create_engine(self) -> Engine:
         """
         Create database Engine object.
 
         Returns
         -------
         Engine object.
@@ -227,14 +233,15 @@
             [
                 dirvername.split("+", 1)[-1]
                 for dirvername in drivernames
             ]
         )
         raise ModuleNotFoundError("module %s not fund" % drivernames_str)
 
+
     def fill_data(
         self,
         data: Union[Dict, List[Dict]],
         sql: Union[str, TextClause],
     ) -> List[Dict]:
         """
         Fill missing data according to contents of sqlClause object of sqlalchemy module, and filter out empty Dict.
@@ -272,14 +279,15 @@
                 val = param.get(key)
                 if val in self.null_values:
                     val = None
                 param[key] = val
 
         return data
 
+
     def execute(
         self,
         sql: Union[str, TextClause],
         data: Optional[Union[List[Dict], Dict]] = None,
         report: bool = False,
         **kwdata: Any
     ) -> CursorResult:
@@ -323,14 +331,15 @@
                     else:
                         rprint(report_info, sql, data, title="SQL", frame=roption.print_default_frame_full)
                 else:
                     result = conn.execute(sql, data)
 
         return result
 
+
     def execute_select(
             self,
             table: str,
             database: Optional[str] = None,
             fields: Optional[Union[str, Iterable]] = None,
             where: Optional[str] = None,
             group: Optional[str] = None,
@@ -422,14 +431,15 @@
         sql = "\n".join(sqls)
 
         # Execute SQL.
         result = self.execute(sql, report=report)
 
         return result
 
+
     def execute_update(
         self,
         data: Union[CursorResult, List[Dict], Dict],
         table: str,
         database: Optional[str] = None,
         where_fields: Optional[Union[str, Iterable[str]]] = None,
         report: bool = False
@@ -507,14 +517,15 @@
         sqls = ";\n".join(sqls)
 
         # Execute SQL.
         result = self.execute(sqls, data_flatten, report)
 
         return result
 
+
     def execute_insert(
         self,
         data: Union[CursorResult, List[Dict], Dict],
         table: str,
         database: Optional[str] = None,
         duplicate_method: Optional[Literal["ignore", "update"]] = None,
         report: bool = False
@@ -579,45 +590,49 @@
             )
 
         # Execute SQL.
         result = self.execute(sql, data, report)
 
         return result
 
+
     def connect(self):
         """
         Create database Connection object.
         """
 
         rconnection = RConnection(
             self.engine.connect(),
             self
         )
 
         return rconnection
 
+
 class RConnection(REngine):
     """
     Rey's database Connection type, based on the package sqlalchemy.
     """
 
+
     def __init__(self, connection: Connection, rengine: REngine) -> None:
         """
         Create database Connection object and set parameters.
 
         Parameters
         ----------
         connection : Connection object.
         rengine : REngine object.
         """
 
         self.connection = connection
         self.rengine = rengine
         self.begin = None
 
+
     def execute(
         self,
         sql: Union[str, TextClause],
         data: Optional[Union[List[Dict], Dict]] = None,
         report: bool = False,
         **kwdata: Any
     ) -> CursorResult:
@@ -663,33 +678,36 @@
             else:
                 rprint(report_info, sql, data, title="SQL", frame=roption.print_default_frame_full)
         else:
             result = self.connection.execute(sql, data)
 
         return result
 
+
     def commit(self) -> None:
         """
         Commit cumulative executions.
         """
 
         # Commit.
         if self.begin != None:
             self.begin.commit()
             self.begin = None
 
+
     def rollback(self) -> None:
         """
         Rollback cumulative executions.
         """
 
         # Rollback.
         if self.begin != None:
             self.begin.rollback()
             self.begin = None
 
+
     def __del__(self) -> None:
         """
         Close database connection.
         """
 
         self.connection.close()
```

## reytool/rdatetime.py

```diff
@@ -5,48 +5,53 @@
 @Time    : 2022-12-05 14:11:50
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's time methods.
 """
 
 
-from typing import Any, Tuple, Dict, Literal, Optional, Union, overload
-import time
-import datetime
+from typing import Any, Dict, Literal, Optional, Union, overload
 from pandas import DataFrame, concat as pd_concat
+from time import time as time_time
+from datetime import (
+    datetime as datetime_datetime,
+    date as datetime_date,
+    time as datetime_time,
+    timedelta as datetime_timedelta
+)
 
-from .rbasic import check_target, is_number_str
-from .rcommon import digits
+from .rbase import check_target, is_number_str
+from .rother import digits
 from .rregular import re_search
 from .rtext import rprint
 
 
 @overload
 def now(
     format: Literal["datetime", "date", "time", "timestamp", "datetime_str", "date_str", "time_str"] = "datetime_str"
-) -> Union[datetime.datetime, datetime.date, datetime.time, int, str]: ...
+) -> Union[datetime_datetime, datetime_date, datetime_time, int, str]: ...
 
 @overload
-def now(format: Literal["datatime"]) -> datetime.datetime: ...
+def now(format: Literal["datatime"]) -> datetime_datetime: ...
 
 @overload
-def now(format: Literal["date"]) -> datetime.date: ...
+def now(format: Literal["date"]) -> datetime_date: ...
 
 @overload
-def now(format: Literal["time"]) -> datetime.time: ...
+def now(format: Literal["time"]) -> datetime_time: ...
 
 @overload
 def now(format: Literal["datetime_str", "date_str", "time_str"]) -> str: ...
 
 @overload
 def now(format: Literal["timestamp"]) -> int: ...
 
 def now(
     format: Literal["datetime", "date", "time", "datetime_str", "date_str", "time_str", "timestamp"] = "datetime_str"
-) -> Union[datetime.datetime, datetime.date, datetime.time, str, int]:
+) -> Union[datetime_datetime, datetime_date, datetime_time, str, int]:
     """
     Get current time string or intger or object.
 
     Parameters
     ----------
     format : Format type.
         - Literal['datetime'] : Return datetime object of datetime package.
@@ -60,162 +65,164 @@
     Returns
     -------
     Time string or object of datetime package.
     """
 
     # Return time object by parameter format.
     if format == "datetime":
-        return datetime.datetime.now()
+        return datetime_datetime.now()
     elif format == "date":
-        return datetime.datetime.now().date()
+        return datetime_datetime.now().date()
     elif format == "time":
-        return datetime.datetime.now().time()
+        return datetime_datetime.now().time()
     elif format == "datetime_str":
-        return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
+        return datetime_datetime.now().strftime("%Y-%m-%d %H:%M:%S")
     elif format == "date_str":
-        return datetime.datetime.now().strftime("%Y-%m-%d")
+        return datetime_datetime.now().strftime("%Y-%m-%d")
     elif format == "time_str":
-        return datetime.datetime.now().strftime("%H:%M:%S")
+        return datetime_datetime.now().strftime("%H:%M:%S")
     elif format == "timestamp":
-        return int(time.time() * 1000)
+        return int(time_time() * 1000)
+
 
 @overload
-def time_to_str(
-    object_: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any],
+def time2str(
+    object_: Union[datetime_datetime, datetime_date, datetime_time, datetime_timedelta, int, Any],
     format: Optional[str] = None,
     throw_error: bool = False
 ) -> Union[str, Any]: ...
 
 @overload
-def time_to_str(object_: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int]) -> str: ...
+def time2str(object_: Union[datetime_datetime, datetime_date, datetime_time, datetime_timedelta, int]) -> str: ...
 
 @overload
-def time_to_str(object_: Any) -> Any: ...
+def time2str(object_: Any) -> Any: ...
 
-def time_to_str(
-    object_: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any],
+def time2str(
+    object_: Union[datetime_datetime, datetime_date, datetime_time, datetime_timedelta, int, Any],
     format: Optional[str] = None,
     throw_error: bool = False
 ) -> Union[str, Any]:
     """
     Format time object of 'datetime' package to string
 
     Parameters
     ----------
     object_ : Object of 'datetime' package or int.
     format : Format string.
         - None : Automatic by type.
-            * Parameter 'object_' is datetime.datetime : Is '%Y-%m-%d %H:%M:%S'.
-            * Parameter 'object_' is datetime.date : Is '%Y-%m-%d'.
-            * Parameter 'object_' is datetime.time : Is '%H:%M:%S'.
-            * Parameter 'object_' is datetime.timedelta : Is f'{days} %H:%M:%S'.
+            * Parameter 'object_' is datetime_datetime : Is '%Y-%m-%d %H:%M:%S'.
+            * Parameter 'object_' is datetime_date : Is '%Y-%m-%d'.
+            * Parameter 'object_' is datetime_time : Is '%H:%M:%S'.
+            * Parameter 'object_' is datetime_timedelta : Is f'{days} %H:%M:%S'.
             * Parameter 'object_' is time stamp : Is '%Y-%m-%d %H:%M:%S'.
         - str : Format by this value.
 
     throw_error : Whether throw error, when parameter 'object_' value error, otherwise return original value.
 
     Returns
     -------
     String after foramt or original value.
     """
 
     # Check parameters.
     if throw_error:
-        check_target(object_, datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int)
+        check_target(object_, datetime_datetime, datetime_date, datetime_time, datetime_timedelta, int)
 
     # Convert to time string.
 
     ## From datetime object.
-    if type(object_) == datetime.datetime:
+    if type(object_) == datetime_datetime:
         if format == None:
             string = str(object_)[:19]
         else:
             string = object_.strftime(format)
 
     ## From date object.
-    elif type(object_) == datetime.date:
+    elif type(object_) == datetime_date:
         if format == None:
             string = str(object_)[:10]
         else:
             string = object_.strftime(format)
 
     ## From time object.
-    elif type(object_) == datetime.time:
+    elif type(object_) == datetime_time:
         if format == None:
             string = str(object_)[:8]
         else:
             string = object_.strftime(format)
 
     ## From timedelta object.
-    elif type(object_) == datetime.timedelta:
+    elif type(object_) == datetime_timedelta:
         if format == None:
             string = str(object_)
             if "day" in string:
                 day, char, string = string.split(" ")
             else:
                 day = "0"
             if string[1] == ":":
                 string = "0" + string
             string = "%s %s" % (day, string[:8])
         else:
             seconds = object_.microseconds / 1000_000
-            datetime_obj = datetime.datetime.fromtimestamp(seconds)
+            datetime_obj = datetime_datetime.fromtimestamp(seconds)
             string = datetime_obj.strftime(format)
 
     ## From int object.
     elif type(object_) == int:
         int_len = len(str(object_))
         if int_len > 10:
             divisor = 10 ** (int_len - 10)
             seconds = object_ / divisor
         else:
             seconds = object_
-        datetime_obj = datetime.datetime.fromtimestamp(seconds)
+        datetime_obj = datetime_datetime.fromtimestamp(seconds)
         if format == None:
             format = "%Y-%m-%d %H:%M:%S"
         string = datetime_obj.strftime(format)
 
     ## From other object.
     else:
         return object_
 
     return string
 
+
 @overload
-def str_to_time(
+def str2time(
     string: Union[str, Any],
     type_: Optional[Literal["datetime", "date", "time", "timedelta", "timestamp"]] = None,
     format: Optional[str] = None,
     throw_error: bool = False
-) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any]: ...
+) -> Union[datetime_datetime, datetime_date, datetime_time, datetime_timedelta, int, Any]: ...
 
 @overload
-def str_to_time(type_: Literal["datetime"]) -> Union[datetime.datetime, Any]: ...
+def str2time(type_: Literal["datetime"]) -> Union[datetime_datetime, Any]: ...
 
 @overload
-def str_to_time(type_: Literal["date"]) -> Union[datetime.date, Any]: ...
+def str2time(type_: Literal["date"]) -> Union[datetime_date, Any]: ...
 
 @overload
-def str_to_time(type_: Literal["time"]) -> Union[datetime.time, Any]: ...
+def str2time(type_: Literal["time"]) -> Union[datetime_time, Any]: ...
 
 @overload
-def str_to_time(type_: Literal["timedelta"]) -> Union[datetime.timedelta, Any]: ...
+def str2time(type_: Literal["timedelta"]) -> Union[datetime_timedelta, Any]: ...
 
 @overload
-def str_to_time(type_: Literal["timestamp"]) -> Union[int, Any]: ...
+def str2time(type_: Literal["timestamp"]) -> Union[int, Any]: ...
 
 @overload
-def str_to_time(type_: None) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, Any]: ...
+def str2time(type_: None) -> Union[datetime_datetime, datetime_date, datetime_time, datetime_timedelta, Any]: ...
 
-def str_to_time(
+def str2time(
     string: Union[str, Any],
     type_: Optional[Literal["datetime", "date", "time", "timedelta", "timestamp"]] = None,
     format: Optional[str] = None,
     throw_error: bool = False
-) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any]:
+) -> Union[datetime_datetime, datetime_date, datetime_time, datetime_timedelta, int, Any]:
     """
     Format string to time object of datetime package
 
     Parameters
     ----------
     string : Time string.
     type_ : Format type.
@@ -312,45 +319,46 @@
         except ValueError:
             if throw_error:
                 raise ValueError("failed to format string as time object")
             return string
 
     # Convert to time type.
     try:
-        time_obj = datetime.datetime.strptime(string, format)
+        time_obj = datetime_datetime.strptime(string, format)
     except ValueError:
         if throw_error:
             raise ValueError("failed to format string as time object")
         return string
     if type_ == "date":
         time_obj = time_obj.date()
     elif type_ == "time":
         time_obj = time_obj.time()
     elif type_ == "timestamp":
         time_obj = int(time_obj.timestamp() * 1000)
     elif type_ == "timedelta":
         second = time_obj.second
         second += day * 86400
-        time_obj = datetime.timedelta(seconds=second)
+        time_obj = datetime_timedelta(seconds=second)
 
     return time_obj
 
+
 @overload
-def is_sql_time(content: Union[str, int], return_datatime: bool = False) -> Union[bool, datetime.datetime]: ...
+def is_sql_time(content: Union[str, int], return_datatime: bool = False) -> Union[bool, datetime_datetime]: ...
 
 @overload
 def is_sql_time(return_datatime: Literal[False]) -> bool: ...
 
 @overload
-def is_sql_time(return_datatime: Literal[True]) -> datetime.datetime: ...
+def is_sql_time(return_datatime: Literal[True]) -> datetime_datetime: ...
 
 def is_sql_time(
     content: Union[str, int],
     return_datatime: bool = False
-) -> Union[bool, datetime.datetime]:
+) -> Union[bool, datetime_datetime]:
     """
     Judge whether it conforms to SQL time format.
 
     Parameters
     ----------
     content : Judge object.
     return_datatime : Whether return datetime object.
@@ -399,40 +407,43 @@
     year_len = len(datetimes_str[0])
     datetimes_str[0] = "2000"[0:4-year_len] + datetimes_str[0]
     year, month, day, hour, minute, second = [
         0 if int_str in ["", None] else int(int_str)
         for int_str in datetimes_str
     ]
     try:
-        datetime.datetime(year, month, day, hour, minute, second)
+        datetime_datetime(year, month, day, hour, minute, second)
     except ValueError:
         return False
 
     # Return datatime object.
     if return_datatime:
-        return datetime.datetime(year, month, day, hour, minute, second)
+        return datetime_datetime(year, month, day, hour, minute, second)
 
     return True
 
+
 class RDateTimeMark():
     """
     Rey's date time mark type.
     """
 
+
     def __init__(self) -> None:
         """
         Mark now time.
         """
 
         # Marking.
         self.mark()
 
+
     def mark(self) -> Dict[
         Literal["index", "timestamp", "datetime", "datetime_str", "interval_timestamp", "interval_timedelta", "interval_timedelta_str"],
-        Optional[Union[str, float, datetime.datetime, datetime.timedelta]]
+        Optional[Union[str, float, datetime_datetime, datetime_timedelta]]
     ]:
         """
         Mark now time and return mark time information.
 
         Returns
         -------
         Mark time information.
@@ -461,20 +472,21 @@
 
         ## Non first.
         else:
             last_datetime = self.record[-1]["datetime"]
             last_timestamp = self.record[-1]["timestamp"]
             mark_info["interval_timestamp"] = mark_info["timestamp"] - last_timestamp
             mark_info["interval_timedelta"] = mark_info["datetime"] - last_datetime
-            mark_info["interval_timedelta_str"] = time_to_str(mark_info["interval_timedelta"])
+            mark_info["interval_timedelta_str"] = time2str(mark_info["interval_timedelta"])
 
         self.record.append(mark_info)
 
         return mark_info
 
+
     def report(self) -> DataFrame:
         """
         Print and return mark time information.
 
         Returns
         -------
         DataFrame object of pandas package with mark time information.
@@ -489,15 +501,15 @@
             }
             for row in self.record
         ]
 
         # Generate report.
         report_df = DataFrame(data)
         interval_timedelta = self.record[-1]["datetime"] - self.record[0]["datetime"]
-        interval = time_to_str(interval_timedelta)
+        interval = time2str(interval_timedelta)
         sum_df = DataFrame({"interval": interval}, index = ["sum"])
         report_df = pd_concat([report_df, sum_df])
         report_df.fillna("-", inplace=True)
 
         # Report.
         title = "Time Mark"
         rprint(report_df, title=title)
```

## reytool/remail.py

```diff
@@ -10,22 +10,23 @@
 
 
 from typing import Dict, Iterable, Optional, Union
 from smtplib import SMTP
 from email.mime.text import MIMEText
 from email.mime.multipart import MIMEMultipart
 
-from .rbasic import get_first_notnull
+from .rbase import get_first_notnull
 
 
 class REmail(object):
     """
     Rey's E-mail type.
     """
 
+
     def __init__(
         self,
         email_username: str,
         email_password: str,
         display_from_email: Optional[str] = None
     ) -> None:
         """
@@ -41,14 +42,15 @@
         """
 
         # Set parameters.
         self.email_username = email_username
         self.email_password = email_password
         self.display_from_email = display_from_email
 
+
     def create_email(
         self,
         text: Optional[str] = None,
         title: Optional[str] = None,
         attachment: Optional[Dict[str, Union[str, bytes]]] = None,
         display_from_email: Optional[str] = None,
         display_to_email: Optional[Union[str, Iterable[str]]] = None,
@@ -88,16 +90,16 @@
             mime["subject"] = title
         if text != None:
             mime_text = MIMEText(text)
             mime.attach(mime_text)
         if attachment != None:
             for file_name, file_data in attachment.items():
                 if type(file_data) == str:
-                    with open(file_data, "rb") as f:
-                        file_data = f.read()
+                    with open(file_data, "rb") as file:
+                        file_data = file.read()
                 mime_file = MIMEText(file_data, _charset="utf-8")
                 mime_file.add_header("content-disposition", "attachment", filename=file_name)
                 mime.attach(mime_file)
         if display_from_email != None:
             mime["from"] = display_from_email
         if display_to_email != None:
             if type(display_to_email) == str:
@@ -111,14 +113,15 @@
                 mime["cc"] = ",".join(display_cc_email)
 
         # Create string in E-mail format.
         email_str = mime.as_string()
 
         return email_str
 
+
     def send_email(
         self,
         to_email: Union[str, Iterable[str]],
         text: Optional[str] = None,
         title: Optional[str] = None,
         attachment: Optional[Dict[str, Union[str, bytes]]] = None,
         cc_email: Optional[Union[str, Iterable[str]]] = None,
```

## reytool/rmonkey.py

```diff
@@ -10,22 +10,24 @@
 
 
 def add_result_more_fetch() -> None:
     """
     Add more methods to CursorResult object of sqlalchemy package.
     """
 
+
     # Version compatible of package sqlalchemy.
     try:
         from sqlalchemy import CursorResult
     except ImportError:
         from sqlalchemy.engine.cursor import LegacyCursorResult as CursorResult
 
     from .rdata import to_table, to_df, to_json, to_sql, to_html, to_csv, to_excel
 
+
     # Fetch SQL result to table in List[Dict] format.
     CursorResult.fetch_table = to_table
 
     # Fetch SQL result to DataFrame object.
     CursorResult.fetch_df = to_df
 
     # Fetch SQL result to JSON string.
@@ -39,22 +41,25 @@
 
     # Fetch SQL result to save csv format file.
     CursorResult.fetch_csv = to_csv
 
     # Fetch SQL result to save excel file.
     CursorResult.fetch_excel = to_excel
 
+
 def support_row_index_by_field():
     """
     Support Row object index by field name.
     """
 
+
     from typing import Any, Union, Sequence, overload
     from sqlalchemy.engine.row import Row
 
+
     # New method.
     @overload
     def __getitem__(self, index: Union[str, int, slice]) -> Union[Any, Sequence[Any]]: ...
 
     @overload
     def __getitem__(self, index: Union[str, int]) -> Any: ...
 
@@ -78,25 +83,29 @@
         if type(index) == str:
             value = self._mapping[index]
         else:
             value = self._data[index]
 
         return value
 
+
     # Modify index method.
     Row.__getitem__ = __getitem__
 
+
 def modify_format_width_judgment() -> None:
     """
     Based on module pprint.pformat, modify the chinese width judgment.
     """
 
-    import pprint
+
+    from pprint import PrettyPrinter, _recursion
     from urwid import old_str_util
 
+
     # Chinese width can be determined.
     def get_width(text: str) -> int:
         """
         Get text display width.
 
         Parameters
         ----------
@@ -112,19 +121,20 @@
         for char in text:
             char_unicode = ord(char)
             char_width = old_str_util.get_width(char_unicode)
             total_width += char_width
 
         return total_width
 
+
     # New method.
     def _format(_self, object, stream, indent, allowance, context, level):
         objid = id(object)
         if objid in context:
-            stream.write(pprint._recursion(object))
+            stream.write(_recursion(object))
             _self._recursive = True
             _self._readable = False
             return
         rep = _self._repr(object, context, level)
         max_width = _self._width - indent - allowance
         width = get_width(rep)
         if width > max_width:
@@ -138,9 +148,10 @@
                 context[objid] = 1
                 _self._pprint_dict(object, stream, indent, allowance,
                                 context, level + 1)
                 del context[objid]
                 return
         stream.write(rep)
 
+
     # Modify the chinese width judgment.
-    pprint.PrettyPrinter._format = _format
+    PrettyPrinter._format = _format
```

## reytool/rregular.py

```diff
@@ -6,90 +6,104 @@
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's regular methods.
 """
 
 
 from typing import List, Tuple, Optional, Union, Literal, overload
-import re
-from re import RegexFlag
+from re import search as _re_search, sub as _re_sub
 
 
-def re_search(pattern: str, text: str, mode: Optional[RegexFlag] = None) -> Optional[Union[str, Tuple[Optional[str], ...]]]:
+def re_search(pattern: str, text: str) -> Optional[Union[str, Tuple[Optional[str], ...]]]:
     """
     Regular matching text.
 
     Parameters
     ----------
     pattern : Regular pattern.
     text : Match text.
-    mode : Regular mode.
-        - None : No mode.
-        - RegexFlag : Use this mode, ojbect from package re.
 
     Returns
     -------
     Matching result.
         - When match to and not use group, then return string.
         - When match to and use group, then return tuple with value string or None.
         - When no match, then return.
     """
 
     # Search.
-    if mode == None:
-        obj_re = re.search(pattern, text)
-    else:
-        obj_re = re.search(pattern, text, mode)
+    obj_re = _re_search(pattern, text)
 
     # Return result.
     if obj_re != None:
         result = obj_re.groups()
         if result == ():
             result = obj_re[0]
         return result
 
+
 @overload
-def res(text: str, *patterns: str, return_first: bool = True) -> Union[
+def res_search(text: str, *patterns: str, first: bool = True) -> Union[
     Optional[Union[str, Tuple[Optional[str], ...]]],
     List[Optional[Union[str, Tuple[Optional[str], ...]]]]
 ]: ...
 
 @overload
-def res(return_first: Literal[True]) -> Optional[Union[str, Tuple[Optional[str], ...]]]: ...
+def res_search(first: Literal[True]) -> Optional[Union[str, Tuple[Optional[str], ...]]]: ...
 
 @overload
-def res(return_first: Literal[False]) -> List[Optional[Union[str, Tuple[Optional[str], ...]]]]: ...
+def res_search(first: Literal[False]) -> List[Optional[Union[str, Tuple[Optional[str], ...]]]]: ...
 
-def res(text: str, *patterns: str, return_first: bool = True) -> Union[
+def res_search(text: str, *patterns: str, first: bool = True) -> Union[
     Optional[Union[str, Tuple[Optional[str], ...]]],
     List[Optional[Union[str, Tuple[Optional[str], ...]]]]
 ]:
     """
     Batch regular matching text.
 
     Parameters
     ----------
     text : Match text.
     pattern : Regular pattern.
-    return_first : Whether return first successful match.
+    first : Whether return first successful match.
 
     Returns
     -------
     Matching result.
         - When match to and not use group, then return string.
         - When match to and use group, then return tuple with value string or None.
         - When no match, then return.
     """
 
     # Search.
 
     ## Return first result.
-    if return_first:
+    if first:
         for pattern in patterns:
             result = re_search(pattern, text)
             if result != None:
                 return result
 
     ## Return all result.
     else:
         result = [re_search(pattern, text) for pattern in patterns]
-        return result
+        return result
+
+def res_sub(text: str, *patterns: Tuple[str, str]) -> str:
+    """
+    Batch regular subbing text.
+
+    Parameters
+    ----------
+    text : Match text.
+    pattern : Regular pattern and replace text.
+
+    Returns
+    -------
+    Subbing result.
+    """
+
+    # Sub.
+    for pattern, replace in patterns:
+        text = _re_sub(pattern, replace, text)
+
+    return text
```

## reytool/rrequest.py

```diff
@@ -6,25 +6,32 @@
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's request methods.
 """
 
 
 from typing import List, Dict, Tuple, Literal, Optional, Union
-import requests
-from requests import Response, JSONDecodeError
+from os.path import abspath as os_path_abspath
+from requests import (
+    Response,
+    JSONDecodeError,
+    get as requests_get,
+    post as requests_post
+)
 from faker import Faker
 
-from .rbasic import get_first_notnull
+from .rbase import get_first_notnull
 from . import roption
+from .rregular import res_search
 
 
 # Global variable Faker object.
 fake: Faker = Faker("zh_CN")
 
+
 def fake_headers() -> Dict:
     """
     Fake request headers.
 
     Returns
     -------
     Fake request headers.
@@ -32,14 +39,15 @@
 
     # Generate.
     headers = {}
     headers['user_agent'] = fake.android_platform_token()
 
     return headers
 
+
 def check_response(
         response: Response,
         code_fields: Optional[List] = None,
         success_codes: Optional[List] = None,
         throw_error: bool = True
     ) -> Tuple[int, str]:
     """
@@ -92,14 +100,15 @@
                     check_info = code, response_data
                     if throw_error:
                         raise AssertionError(code, response_data)
                     return check_info
 
     return 200, "success"
 
+
 def request(
     url: str,
     data: Optional[Dict] = None,
     json: Optional[Dict] = None,
     headers: Optional[Union[Dict, Literal["fake"]]] = None,
     timeout: Optional[Union[int, float]] = None,
     proxies: Optional[Dict[str, str]] = None,
@@ -161,16 +170,54 @@
         else:
             method = "post"
     if headers == "fake":
         headers = fake_headers()
 
     # Request.
     if method == "get":
-        response = requests.get(url, data=data, json=json, headers=headers, timeout=timeout, proxies=proxies)
+        response = requests_get(url, data=data, json=json, headers=headers, timeout=timeout, proxies=proxies)
     elif method == "post":
-        response = requests.post(url, data=data, json=json, headers=headers, timeout=timeout, proxies=proxies)
+        response = requests_post(url, data=data, json=json, headers=headers, timeout=timeout, proxies=proxies)
 
     # Check.
     if check:
         check_response(response, code_fields, success_codes)
 
-    return response
+    return response
+
+
+def download(url: str, path: Optional[str] = None) -> str:
+    """
+    Download file from URL.
+
+    Parameters
+    ----------
+    url : Download URL.
+    path : Save path.
+        * None : File name is 'download' and auto judge file type.
+
+    Returns
+    -------
+    File absolute path.
+    """
+
+    # Download.
+    response = request(url)
+    content = response.content
+
+    # Judge file type and path.
+    if path == None:
+        headers = response.headers
+        content_type = headers["Content-Type"]
+        pattern = "^[^/]*/([^;\s]+).*$"
+        result = res_search(content_type, pattern)
+        if result != None:
+            path = "download." + result[0]
+        else:
+            path = "download"
+        path = os_path_abspath(path)
+
+    # Save.
+    with open(path, "wb") as file:
+        file.write(content)
+
+    return path
```

## reytool/rtext.py

```diff
@@ -6,25 +6,26 @@
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's text methods.
 """
 
 
 from typing import Any, List, Literal, Optional
-import pprint
+from pprint import pformat as pprint_pformat
 from urwid import old_str_util
 
-from .rbasic import get_first_notnull, get_name
+from .rbase import get_first_notnull, get_name
 from .rmonkey import modify_format_width_judgment
 from . import roption
 
 
 # Based on module pprint.pformat, modify the chinese width judgment.
 modify_format_width_judgment()
 
+
 def split_text(text: str, man_len: int, by_width: bool = False) -> List[str]:
     """
     Split text by max length or not greater than display width.
 
     Parameters
     ----------
     text : Text.
@@ -66,14 +67,15 @@
             start_indxe = man_len * n
             end_index = man_len * (n + 1)
             text_group = text[start_indxe:end_index]
             texts.append(text_group)
 
     return texts
 
+
 def get_width(text: str) -> int:
     """
     Get text display width.
 
     Parameters
     ----------
     text : Text.
@@ -88,14 +90,15 @@
     for char in text:
         char_unicode = ord(char)
         char_width = old_str_util.get_width(char_unicode)
         total_width += char_width
 
     return total_width
 
+
 def fill_width(text: str, char: str, width: int, align: Literal["left", "right", "center"] = "right") -> str:
     """
     Text fill character by display width.
 
     Parameters
     ----------
     text : Fill text.
@@ -130,14 +133,15 @@
         else:
             raise ValueError("parameter 'align' value error")
     else:
         new_text = text
 
     return new_text
 
+
 def print_frame(
     *contents: Any,
     title: Optional[str] = None,
     width: Optional[int] = None,
     frame: Optional[Literal["full", "half", "plain"]] = None
 ) -> None:
     """
@@ -223,14 +227,15 @@
     print(frame_top)
     for index, content in enumerate(_contents):
         if index != 0:
             print(frame_split)
         print(content)
     print(frame_bottom)
 
+
 def rprint(
         *contents: Any,
         title: Optional[str] = None,
         width: Optional[int] = None,
         frame: Optional[Literal["full", "half", "plain"]] = None,
         format: bool = True
     ) -> None:
@@ -274,15 +279,15 @@
     # Format contents.
     if format:
         if frame == "full":
             _width = width - 2
         else:
             _width = width
         contents = [
-            pprint.pformat(content, width=_width, sort_dicts=False)
+            pprint_pformat(content, width=_width, sort_dicts=False)
             if type(content) in [list, tuple, dict, set]
             else content
             for content in contents
         ]
 
     # Print.
     print_frame(*contents, title=title, width=width, frame=frame)
```

## reytool/rwrap.py

```diff
@@ -10,15 +10,15 @@
 
 
 from typing import Any, Tuple, Callable, Optional, Union, Literal, overload
 from tqdm import tqdm as tqdm_tqdm
 from threading import Thread
 from functools import wraps as functools_wraps
 
-from .rcommon import exc
+from .rother import exc
 from .rtext import print_frame
 from .rdatetime import RDateTimeMark, now
 
 
 def wrap_frame(decorator: Callable) -> Callable:
     """
     Decorative frame.
@@ -98,14 +98,15 @@
 
             return func_ret
 
         return wrap_sub
 
     return wrap
 
+
 def wraps(*wrap_funcs: Callable) -> Callable:
     """
     Batch decorate.
 
     Parameters
     ----------
     wrap_funcs : Decorator function.
@@ -161,14 +162,15 @@
 
             return wrap_sub
 
         func = wrap
 
     return wrap
 
+
 @overload
 def runtime(func: Callable, *args: Any, _ret_report: bool = False, **kwargs: Any) -> Union[Any, Tuple[Any, str]]: ...
 
 @overload
 def runtime(_ret_report: Literal[False]) -> Any: ...
 
 @overload
@@ -210,14 +212,15 @@
         return func_ret, report
 
     # Print report.
     print_frame(report, title=title)
 
     return func_ret
 
+
 @overload
 def start_thread(func: Callable, *args: Any, _daemon: bool = True, **kwargs: Any) -> Thread: ...
 
 @wrap_frame
 def start_thread(func: Callable, *args: Any, _daemon: bool = True, **kwargs: Any) -> Thread:
     """
     Function start in thread.
@@ -242,14 +245,15 @@
     thread.daemon = _daemon
 
     # Start thread.
     thread.start()
 
     return thread
 
+
 @overload
 def try_exc(func: Callable, *args: Any, **kwargs: Any) -> Optional[Any]: ...
 
 @wrap_frame
 def try_exc(func: Callable, *args: Any, **kwargs: Any) -> Optional[Any]:
     """
     Execute function with 'try' syntax and print error information.
@@ -274,14 +278,15 @@
         func_name = func.__name__
         exc(func_name)
 
     # Return function result.
     else:
         return func_ret
 
+
 @overload
 def update_tqdm(
     func: Callable,
     tqdm: tqdm_tqdm,
     *args: Any,
     _desc: Optional[str] = None,
     _step: Union[int, float] = 1,
```

## reyworm/__init__.py

```diff
@@ -7,11 +7,9 @@
 @Contact : reyxbo@163.com
 @Explain : Rey's personal worm set.
 """
 
 
 from typing import Final
 
-from .rtranslate import translate
 
-
-__version__: Final[str] = "0.3"
+__version__: Final[str] = "0.4"
```

## reyworm/rtranslate.py

```diff
@@ -23,39 +23,49 @@
 
     Retuens
     -------
     str
         Translated text.
     """
 
+    # Set parameters.
     url = r"https://fanyi.baidu.com/sug"
     data = {
         "kw": text
     }
+
+    # Requests.
     response = request(url, data)
     response_data = response.json()["data"]
+
+    # Handle result.
     if not len(response_data):
         return
     translate_data = response_data[0]["v"]
     translate_text = translate_data.split(";")[0].split(". ")[-1]
+
     return translate_text
 
+
 def translate(text: str) -> str:
     """
     translated text.
 
     Parameters
     ----------
     text : Text to be translated.
 
     Retuens
     -------
     Translated text.
     """
 
+    # Set parameters.
     translate_func = [
         translate_baidu
     ]
+
+    # Translate.
     for func in translate_func:
         translate_text = func(text)
         if translate_text != None:
             return translate_text
```

## Comparing `reytool/rbasic.py` & `reytool/rbase.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,14 +35,15 @@
             warn_infos = str(warn_infos[0])
     else:
         warn_infos = str(warn_infos)
 
     # Throw warning.
     warnings_warn(warn_infos, warn_type, stacklevel)
 
+
 def check_target(value: Any, *targets: Union[Any, Literal["_iterable"]], check_element: bool = False) -> None:
     """
     Check the content or type of the value, when check fail, then throw error.
 
     Parameters
     ---------
     value : Check object.
@@ -93,14 +94,15 @@
                 "parameter%s the content or type must in [%s], now: %s" % (
                     var_name,
                     correct_targets_str,
                     repr(value)
                 )
             )
 
+
 def check_least_one(*values: Any) -> None:
     """
     Check that at least one of multiple values is not None, when check fail, then throw error.
 
     Parameters
     ----------
     values : Check values.
@@ -117,14 +119,15 @@
         vars_name_de_dup = list(set(vars_name))
         vars_name_de_dup.sort(key=vars_name.index)
         vars_name_str = " " + " and ".join(["'%s'" % var_name for var_name in vars_name_de_dup])
     else:
         vars_name_str = ""
     raise ValueError("at least one of parameters%s is not None" % vars_name_str)
 
+
 def check_most_one(*values: Any) -> None:
     """
     Check that at most one of multiple values is not None, when check fail, then throw error.
 
     Parameters
     ----------
     values : Check values.
@@ -143,14 +146,15 @@
             vars_name_de_dup = list(set(vars_name))
             vars_name_de_dup.sort(key=vars_name.index)
             vars_name_str = " " + " and ".join(["'%s'" % var_name for var_name in vars_name_de_dup])
         else:
             vars_name_str = ""
         raise ValueError("at most one of parameters%s is not None" % vars_name_str)
 
+
 def is_iterable(obj: Any, exclude_types: Iterable[Type] = [str, bytes]) -> bool:
     """
     Judge whether it is iterable.
 
     Parameters
     ----------
     obj : Judge object.
@@ -171,14 +175,15 @@
     except TypeError:
         return False
     if "__iter__" in obj_dir:
         return True
     else:
         return False
 
+
 def is_table(obj: Any, check_fields: bool = True) -> bool:
     """
     Judge whether it is List[Dict] table format and keys and keys sort of the Dict are the same.
 
     Parameters
     ----------
     obj : Judge object.
@@ -204,14 +209,15 @@
         ]
         keys_strs_only = set(keys_strs)
         if len(keys_strs_only) != 1:
             return False
 
     return True
 
+
 def is_number_str(text: str) -> bool:
     """
     Judge whether it is number string.
 
     Parameters
     ----------
     text : Judge text.
@@ -229,14 +235,15 @@
         else:
             number = int(text)
     except ValueError:
         return False
 
     return True
 
+
 def get_first_notnull(
     *values: Any,
     default: Optional[Union[Any, Literal["error"]]] = None,
     null_values: List = [None]) -> Any:
     """
     Get the first value that is not null.
 
@@ -268,14 +275,15 @@
             vars_name_str = " " + " and ".join(["'%s'" % var_name for var_name in vars_name_de_dup])
         else:
             vars_name_str = ""
         raise ValueError("at least one of parameters%s is not None" % vars_name_str)
 
     return default
 
+
 def ins(obj: Any, *arrays: Iterable) -> bool:
     """
     Judge whether the object is in multiple array.
 
     Parameters
     ----------
     obj : Judge object.
@@ -289,14 +297,15 @@
     # Judge.
     for array in arrays:
         if obj in array:
             return True
 
     return False
 
+
 def mutual_in(*arrays: Iterable) -> bool:
     """
     Whether the same element exists in multiple array.
 
     Parameters
     ----------
     arrays : Array.
@@ -314,14 +323,15 @@
         for after_array in arrays[n+1:]:
             for element in array:
                 if ins(element, after_array):
                     return True
 
     return False
 
+
 def to_type(obj: Any, to_type: Type, method: Optional[Callable] = None) -> Any:
     """
     Convert object type.
 
     Parameters
     ----------
     obj : Convert object.
@@ -341,14 +351,15 @@
 
     # Convert type.
     if method != None:
         return method(obj)
     else:
         return to_type(obj)
 
+
 def get_name(obj: Any, frame: int = 2) -> Optional[Union[str, Tuple[str, ...]]]:
     """
     Get object name.
 
     Parameters
     ----------
     obj : Object.
```

